 import pandas as pd
 import numpy as np
 import matplotlib.pyplot as plt
 import seaborn as sns

df = pd.read_csv("uber.csv")

df

df.head()

df.tail()

df.shape

 df.size

 df.info()

df.describe()

 df.isnull()

 df.isnull().sum()

from sklearn.model_selection import train_test_split
 from sklearn.linear_model import LinearRegression
 from sklearn.ensemble import RandomForestRegressor
 from sklearn.metrics import r2_score, mean_squared_error

 df = df.dropna()

 df['pickup_datetime'] = pd.to_datetime(df['pickup_datetime'], errors='coerce')

 df['hour'] = df['pickup_datetime'].dt.hour
 df['day_of_week'] = df['pickup_datetime'].dt.dayofweek
 df['month'] = df['pickup_datetime'].dt.month

 df = df[(df['passenger_count'] > 0) & (df['passenger_count'] <= 6)]

 df = df[df['fare_amount'] > 0]

 def haversine_distance(lat1, lon1, lat2, lon2):
 """
 Calculate the great circle distance between two points
 on the earth (specified in decimal degrees)
 Returns distance in kilometers.
 """
 # convert decimal degrees to radians
 lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])
 dlat = lat2-lat1
 dlon = lon2-lon1
 a = np.sin(dlat/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2.0)**2
 c = 2 * np.arcsin(np.sqrt(a))
km = 6371 * c
 return km
 df['distance_km'] = haversine_distance(df['pickup_latitude'], df['pickup_longitude'
 df['dropoff_latitude'], df['dropoff_longitude'
 # Remove trips with zero or extremely small distance (likely errors)
 df = df[df['distance_km'] > 0.01]


 plt.figure(figsize=(8,4))
 sns.boxplot(x=df['fare_amount'])
 plt.title('Fare Amount Boxplot')
 plt.show()

 from scipy import stats
 z_fare = np.abs(stats.zscore(df['fare_amount']))
 z_distance = np.abs(stats.zscore(df['distance_km']))

threshold = 3

df_clean = df[(z_fare < threshold) & (z_distance < threshold)]

print(f"Original dataset size: {len(df)}")
 print(f"Dataset size after removing outliers: {len(df_clean)}")


 corr_matrix = df_clean[['fare_amount', 'distance_km', 'passenger_count', 'hour'
 print("Correlation matrix:")
 print(corr_matrix)
 plt.figure(figsize=(8,6))
 sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')
 plt.title('Feature Correlation Matrix')
 plt.show()

features = ['distance_km', 'passenger_count', 'hour', 'day_of_week', 'month']
 X = df_clean[features]
 y = df_clean['fare_amount']

 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state

 lr_model = LinearRegression()
 lr_model.fit(X_train, y_train)
 y_pred_lr = lr_model.predict(X_test)

 rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
 rf_model.fit(X_train, y_train)
 y_pred_rf = rf_model.predict(X_test)

 def evaluate_model(y_true, y_pred, model_name):
 r2 = r2_score(y_true, y_pred)
 rmse = np.sqrt(mean_squared_error(y_true, y_pred))
 print(f"{model_name} Performance:")
 print(f"R2 Score: {r2:.4f}")
 print(f"RMSE: {rmse:.4f}")
 print("-" * 30)
 return r2, rmse

 r2_lr, rmse_lr = evaluate_model(y_test, y_pred_lr, "Linear Regression")
 r2_rf, rmse_rf = evaluate_model(y_test, y_pred_rf, "Random Forest Regression")

plt.figure(figsize=(8,6))
 plt.scatter(y_test, y_pred_rf, alpha=0.3)
 plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
 plt.xlabel('Actual Fare Amount')
 plt.ylabel('Predicted Fare Amount')
 plt.title('Random Forest: Actual vs Predicted Fare Amount')
 plt.show()

plt.figure(figsize=(8,6))
 plt.scatter(y_test, y_pred_lr, alpha=0.3)
 plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
 plt.xlabel('Actual Fare Amount')
 plt.ylabel('Predicted Fare Amount')
 plt.title('Linear Regression: Actual vs Predicted Fare Amount')
 plt.show()
